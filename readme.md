# Увод

През последните години, областта на софтуерната разработка претърпява забележителна промяна, еволюирайки от интензивни и трудоемки задачи към по-автоматизирани и интелигентни процеси. До 2023г. традиционните практики за разработване на софтуер разчитаха предимно на човешката експертиза, итеративно писане и преглеждане на код, изчерпателно тестване. Напредъкът на Изкуствения Интелект (ИИ) обаче, е на път коренно да промени съществуващото статукво. Използването на инструменти базирани на ИИ, осезаемо води до промени в ефективността, скоростта на разработката и иновациите в организирането на самия процес.

Алгоритмите за машинно обучение, сложни ИИ модели, като GPT (Generative Pre-trained Transformer) както и напредъка в областта на обработката на естествен език (NLP) и големите езикови модели (LLM), значително повлияват в разнообразни аспекти от жизнения цикъл на софтуерната разработка. ИИ алгоритми могат да анализират големи обеми от данни за да идентифицират пазарни нужди и потребителски предпочитания, намалявайки трудностите при процеса на събирането на изисквания. ИИ базирани системи могат да автоматизират и оптимизират аспекти от процеса на UI/UX дизайн, базирайки се на добри практики и потребителски данни. ИИ може да автоматизира генерирането на тестове, да изпълнява тестове и да анализира резултатите за по-бърза обратна връзка. Всички етапи от жизнения цикъл на софтуерната разработка, като дизайн, тестване, разработка, внедряване, управление и поддръжка, са повлияни до различна степен от напредъка в развитието на ИИ и по-специално в частта му свързана с дълбоко обучение, невроните мрежи и чисто технологичните възможности на инфраструктурата даваща възможност за използването на голям обем от данни за тренирането на ML модели.

Тази курсова работа има за цел да подложи на тест някои от съществуващите инструменти, които поддържат генерирането на компютърен код и да се опита да установи до каква степен тези инструменти ще променят начина по-който се създават софтуерни решения. Този текст е създаден и редактиран като MarkDown формат във Visual Studio Code. По време на писането на текста е включен Github Copilot - инструмент за автоматизирано генериране на текст и компютърен код, базиран на GPT-3.5. Copilot ще бъде използван единствено за генерирането на код, който, за по-добра видимост ще бъде маркиран чрез коментар или друг подходящ начин.

## Експеримент - разработване на уеб базирано приложение с помощта на Github Copilot и ChatGPT

Задачата, която трябва да бъде решена с този експеримент е свързана с разработването на уеб базирано приложение (***Pulse Point - предложено от chat GPT4***), което дава възможност на потребителя да води дневник (log) на избрани от него показатели, свързани основно със здравето и здравословния начин на живот. Приложението ще бъде разработено с React и Typescript. To ще дава възможност да се проследи движението на даден показател / показатели във времето чрез графика. Като начало, потребителят ще въвежда данните ръчно. Данните, с които ще работи приложението ще следват следния формат:

```typescript
// Typescript

// Основен интерфейс определящ вида на конкретния показател.
interface Metric{
    id: string;             // уникален идентификатор на показателя
    name: string;           // име на показателя
    description: string;    // описание на показателя - това поле беше препоръчано от Github Copilot
    unit: string;           // мерна единица за показателя
    preferredValue: number | null;  // предпочитана стойност, ако има такава.
    referenceRange:{    // референтни стойности, ако има такива.
        min:number;
        max:number | null;
    } | null;
}


// Интерфейс за конкретно измерване на показател
interface DataPoint {
    metricId:string;    // уникален идентификатор на показателя
    value: number;      // стойност
    date: string;       // дата на измерване на стойността
    comment: string     // коментар към стойността - това поле беше препоръчано от Github Copilot
}
```

Примерен случай на употреба може да изглежда по следният начин:

1. Потребителя прави кръвни изследвания в лаборатория и получава резултати.
2. Потребителят търси показателя в базата данни на приложението.
    * Ако показателят съществува в базата данни, потребителят го избира и добавя стойността от изследването.
    * Ако показателя не съществува в базата данни, потребителят го добавя, след което добавя стойността от изследването.
3. Приложението преминава към страница с обобщена информация. Ако стойността на показателя е извън референтните стойности, потребителският интерфейс подобаващо отразява несъответствието.

Други функционалности, които приложението може да има:
1. Визуализация на данните в графики.
2. Избиране на множество показатели за едновременно визуализиране.
3. **Възможност за добавяне на коментари към конкретна стойност на показател.**(препоръчано от Github Copilot)
4. **Възможност за добавяне на описание на показател.** (препоръчано от Github Copilot)

### Инициализация на проекта

Проектът е реализиран със Vite - инструмент за създаване на проекти със съвременни технологии като React, Vue, Typescript и други. Vite е избран поради скоростта на създаване на проекта и възможността за използване на Typescript.

След началната инициализация, от генерираният код са премахнати ненужните части, като например демонстрационния компонент, който е генериран по подразбиране.

### Деклариране на типовете и дефиниране на работна база данни

След като проектът е инициализиран, следва да се дефинират типовете, които ще се използват в приложението. Типовете са дефинирани във файл [data.d.ts](pulse-point-app/src/types/data.d.ts). Този файл съдържа споменатите по-горе дефиниции на типове, които са общи за цялото приложение.

Следва да се създаде статична (mock) база от данни, която да послужи по време на разработката. Първата част от нея е колекция от предварително дефинирани показатели - [metrics.ts](pulse-point-app/src/mockDB/metrics.ts).

> Наблюдение:
>
> След като бяха въведени първите четири показателя, Copilot добави останалите показатели от файла, спазвайки същият формат и контекста на данните.

Втората част от базата данни е колекция от данни за конкретни измервания - [dataPoints.ts](pulse-point-app/src/mockDB/dataPoints.ts). Тази колекция съдържа данни за конкретни измервания на показателите, които са дефинирани в предходната колекция.

> Наблюдение:
>
> Copilot генерира всички измервания, разполагайки само с името на файла [dataPoints.ts](pulse-point-app/src/mockDB/dataPoints.ts) и контекста на проекта до момента.

### API за работа с данните

След като вече имаме основните типове и тестова структура от данни, с които приложението ще работи ще дефинираме API, което да дава възможност на компонентите от приложението да работят с тези данни.

1. Искаме от ChatGPT автоматично да генерира API.
Резултата от първият промпт може да бъде видян на [create-api_01](/gpt_prompts/01.create-api_01.md).

>Както се вижда във файла, chatGPT генерира основния клас TestAPI, както и методи за добавяне на нови показатели и измервания. В генерираните коментари, той също прави и предложения за валидация на данните, които се добавят.

2. Искаме от ChatGPT да добави проверка за дублиране на показатели. 

> Генерирания код прави точно това. Ако в базата данни съществува показател със същият id, то той не се добавя и API-то връща съобщение за грешка.
> (целият код тук -> [create-api_02](/gpt_prompts/02.create-api_02.md))
```typescript
...
 if (this.metrics.some(existingMetric => existingMetric.id === metric.id)) {
            throw new Error(`A metric with id ${metric.id} already exists.`);
        }
...
```

3. Искаме възможност да извличаме измервания само за даден показател, сортирани по дата. 

> Полученият резултат е следният: 
>
>(целият код тук -> [create-api_03](/gpt_prompts/03.create-api_03.md))
```typescript
...
public getDataPointsForMetric(metricId: string): DataPoint[] {
        return this.dataPoints
            .filter(dataPoint => dataPoint.metricId === metricId)
            .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    }
...
```

4. Правим опит да допишем останалите методи от API-то, използвайки  Github Copilot. Стратегията е да пишем текстови коментари и да очакваме Copilot да генерира кода, вземайки под внимание тези коментари.

> Github Copilot успешно генерира методи за премахване и редактиране, както на измервания, така и на показатели. По време на генерацията на методите за редактиране и премахване на измерване, Copilot допуска грешка, като използва търсене на измерване по id, което поле не съществува в дефиницията на типа dataPoint. Решавам да променя полето `date` на `timestamp`. По този начин ще можем да идентифицираме дадено измерване по уникално времево означение. След тази промяна, Copilot успешно генерира методите за редактиране и премахване на измерване. Завършения код може да се види в [Api.ts](pulse-point-app/src/Api.ts).

5. Обратно в ChatGPT, искаме от него да генерира тестове за API-то, като му даваме изходния код. [test-api_01](/gpt_prompts/04.test-api_01.md)

>Получаваме отговор, който включва тестове за някои от методите в Api.ts, но не за всички.

6. Искаме от ChatGPT да генерира тестове за всички методи в Api.ts. [test-api_02](/gpt_prompts/05.test-api_02.md)

> ChatGPT генерира тестове за всички методи в Api.ts. Тестовете са генерирани с Jest - популярна библиотека за тестване на Javascript код. Един проблем (или не) възниква. Генерирания код използва полето `date` от dataPoint. В контекста на ChatGPT, точно това поле трябва да бъде използвано. Той няма информация за това, че ние сме променили полето от `date` на `timestamp`. Правим ръчна корекция на в тестовия файл и стартираме тестовете. Те минават успешно.
>
> Тестовият файл може да бъде видян тук [Api.test.ts](pulse-point-app/src/tests/Api.test.ts)








